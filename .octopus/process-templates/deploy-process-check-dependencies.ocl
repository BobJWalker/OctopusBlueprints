name = "Deploy Process - Check Dependencies"
description = "A process template that will ensure all the required dependent projects are deployed."

parameter "Template.Worker.Pool" {
    display_settings = {
        Octopus.ControlType = "WorkerPool"
    }
    help_text = "**Required** - The worker pool where this script will run."
    label = "Worker Pool"
}

parameter "Template.Octopus.Api.Key" {
    display_settings = {
        Octopus.ControlType = "Sensitive"
    }
    help_text = <<-EOT
            **Required** - Octopus Deploy API Key with permissions to:
            
            - Query for spaces, projects, environments, releases, deployments, and tenants
            - Trigger deployments for the dependencies (if that option is chosen)
            EOT
    label = "Octopus Deploy API Key"
}

parameter "Template.Dependency.Projects" {
    display_settings = {
        Octopus.ControlType = "MultiLineText"
    }
    help_text = <<-EOT
            **Required** - JSON Array Representing the dependencies for this project.
            
            ```
            [
              {
                "projectName": "Spear", 
                "versionPattern": ">1.0.42", 
                "deployGroup": 1,    
                "spaceName": "Default",
                "tenantName": null 
              },
              {
                "versionPattern": "^2.4.0",
                "spaceName": "Default",
                "projectName": "TAKA",
                "deployGroup": 1
              },
              {
                "versionPattern": "4.x",
                "spaceName": "Default",
                "projectName": "TAWA",
                "deployGroup": 2
              }
            ]
            ```
            
            The properties to note are:
            
            - projectName - **Required** the name of the project of the dependency.
            - versionPattern- **Required** the version pattern to match on.  See below for version information.
            - deployGroup - **Optional** indicates which projects can be deployed concurrently vs. which ones that cannot.  If omitted all dependencies are deployed sequentially.
            - spaceName - **Optional** uses the current space if not provided.
            - tenantName - **Optional** the name of the tenant to deploy.  If not specified will use the current tenant being deployed (if doing a tenanted deployment)
            
            The minimum version follows Node's versioning scheme.  But it includes support for four digits (1.2.3.4) as well as three (1.2.3).  Any pre-release tags are removed prior to comparison.
            
            - Exact version: 1.2.3.4 - only version 1.2.3.4 will be accepted.
            - Greater than current: >1.2.3.4 - Any version greater than or equal to 1.2.3.4 will be accepted.  
            - Caret range: ^1.2.3.4 - Allows minor, patch, and build updates, locking the major version.  Similar to 1.x.
            - Tilde range: ~1.2.3.4 - Allows patch and build updates only, locking the major and minor versions.
            - Major wildcard: 2.x - Allows any version or any version within a major range.
            EOT
    label = "Project Dependencies"
}

parameter "Template.Dependency.Action" {
    display_settings = {
        Octopus.ControlType = "Select"
        Octopus.SelectOptions = <<-EOT
            Stop|Stop Deployment
            Continue|Continue Deploy
            DeployNoMatchingInTarget|Deploy only when no matching found
            DeployNewerMatching|Deploy when newer matching found
            EOT
    }
    help_text = <<-EOT
            **Required** - Indicates what this template should do when a dependency check fails.
            
            - **Stop:** If one or more of the dependency checks fail it will stop and fail the deployment.
            - **Continue:** Will proceed with the deployment even if the dependency check fails.  Will not attempt to deploy any dependent projects.
            - **Deploy when newer matching found:** Will always deploy the latest matching version from the previous environment.  
            - **Deploy only when no matching found:** Will trigger a deployment to the target environment only if the target environment doesn't include a matching version.  
            
            The deploy options control when a deployment will occur.  For example, your pattern is >4.5.2.  
            
            - Test 1 - The latest version in Production is 4.1.2 and in Test it is 4.5.7.  Deploy when newer will deploy 4.5.7.  Deploy when no matching will deploy 4.5.7.
            - Test 2 - The latest version in Production is 4.5.3 and in test it is 4.5.7.  Deploy when newer will deploy 4.5.7.  Deploy when no matching WILL NOT deploy 4.5.7 because 4.5.3 matches the pattern >4.5.2.
            EOT
    label = "Dependency Action"

    value "Stop" {}
}

parameter "Template.Environment.Name" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = "**Required** - The name of the target environment you want to check and deploy dependencies to."
    label = "Target Environment"

    value "#{Octopus.Environment.Name}" {}
}

parameter "Template.Dependency.Approval" {
    display_settings = {
        Octopus.ControlType = "Select"
        Octopus.SelectOptions = <<-EOT
            Yes|Yes
            No|No
            EOT
    }
    help_text = <<-EOT
            **Required** - Request approval via a manual intervention if the dependency check fails and you wish to continue or deploy the child dependencies.  Setting this to Yes DOES NOT guarantee a manual intervention will run.  
            
            - If the Dependency Action is set to Stop, it will fail the deployment and not run the manual intervention.
            - If all the dependencies pass the check, it will continue without running the manual intervention.
            
            The log will indicate if an manual intervention was determined to be needed.
            EOT
    label = "Approval requested to proceed"

    value "Yes" {}
}

parameter "Template.Approval.Teams" {
    display_settings = {
        Octopus.ControlType = "Teams"
    }
    help_text = "**Required** - The list of teams who can approval the manual intervention."
    label = "Approval Teams"
}

parameter "Template.Tenant.Name" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = "**Optional** - The name of the tenant you want to check and deploy the dependencies for"
    is_optional = true
    label = "Target Tenant"

    value "#{Octopus.Deployment.Tenant.Name}" {}
}

step "check-dependencies" {
    name = "Check Dependencies"

    action {
        action_type = "Octopus.Script"
        properties = {
            Octopus.Action.RunOnServer = "true"
            Octopus.Action.Script.ScriptBody = <<-EOT
                $parameterOctopusAPIKey = $OctopusParameters["Template.Octopus.Api.Key"]
                $parameterOctopusInstance = $OctopusParameters["Octopus.Web.ServerUri"]
                $parameterDependencies = $OctopusParameters["Template.Dependency.Projects"]
                $parameterOlderDependencyAction = $OctopusParameters["Template.Dependency.Action"]
                
                $parameterTargetEnvironmentName = $OctopusParameters["Template.Environment.Name"] # Target environment for deployment
                $parameterTargetTenantName = $OctopusParameters["Template.Tenant.Name"] # Target Tenant for deployment (when doing multi-tenancy)
                $parameterSpaceName = $OctopusParameters["Octopus.Space.Name"] # Space name to use for API calls, if not specified will attempt to look up based on space name
                $stepName = $OctopusParameters["Octopus.Action.StepName"]
                $parameterApprovalRequested = $OctopusParameters["Template.Dependency.Approval"] # Indicates if approval was requested
                
                Write-Host "Octopus Instance: $parameterOctopusInstance"
                Write-Host "Dependencies: $parameterDependencies"
                Write-Host "Dependency Action: $parameterOlderDependencyAction"
                Write-Host "Approval Requested: $parameterApprovalRequested"
                Write-Host "Target Environment Name: $parameterTargetEnvironmentName"
                Write-Host "Target Tenant Name: $parameterTargetTenantName"
                Write-Host "Target Space Name: $parameterSpaceName"
                
                function Get-OctopusUrl
                {
                    param (
                        $EndPoint,
                        $SpaceId,
                        $OctopusUrl
                    )
                
                    $octopusUrlToUse = $OctopusUrl
                    if ($OctopusUrl.EndsWith("/"))
                    {
                        $octopusUrlToUse = $OctopusUrl.Substring(0, $OctopusUrl.Length - 1)
                    }
                
                    if ($EndPoint -match "/api")
                    {
                        if (!$EndPoint.StartsWith("/api"))
                        {
                            $EndPoint = $EndPoint.Substring($EndPoint.IndexOf("/api"))
                        }
                
                        return "$octopusUrlToUse$EndPoint"
                    }
                
                    if ([string]::IsNullOrWhiteSpace($SpaceId))
                    {
                        return "$octopusUrlToUse/api/$EndPoint"
                    }
                
                    return "$octopusUrlToUse/api/$spaceId/$EndPoint"
                }
                
                function Invoke-OctopusApi
                {
                    param
                    (
                        $octopusUrl,
                        $spaceId,
                        $endPoint,
                        $apiKey,
                        $method,
                        $item,        
                        $retryCount
                    )
                
                    try
                    {        
                        $url = Get-OctopusUrl -EndPoint $endPoint -SpaceId $spaceId -OctopusUrl $octopusUrl
                
                        if ($null -eq $item)
                        {
                            Write-Verbose "No data to post or put, calling bog standard invoke-restmethod for $url"
                            return Invoke-RestMethod -Method $method -Uri $url -Headers @{"X-Octopus-ApiKey" = "$ApiKey" } -ContentType 'application/json; charset=utf-8' -TimeoutSec 60
                        }
                
                        $body = $item | ConvertTo-Json -Depth 10
                        Write-Verbose $body
                
                        Write-Verbose "Invoking $method $url"
                        return Invoke-RestMethod -Method $method -Uri $url -Headers @{"X-Octopus-ApiKey" = "$ApiKey" } -Body $body -ContentType 'application/json; charset=utf-8' -TimeoutSec 60
                    }
                    catch [System.TimeoutException]
                    {        
                        $newRetryCount = 1
                        if ($null -ne $retryCount)
                        {
                            $newRetryCount = $retryCount + 1
                        }
                
                        if ($newRetryCount -gt 4)
                        {
                            Throw "Timeout detected, max retries has been exceeded for this call.  Exiting."
                        }
                        else 
                        {
                            Write-Host "Timeout detected, going to retry this call for the $newRetryCount time."
                            Invoke-OctopusApi -url $url -apiKey $apiKey -method $method -item $item -filePath $filePath -retryCount $retryCount        
                        }
                    }
                    catch
                    {
                        Write-Error "There was an error making a $method call to $url.  All request information (JSON body specifically) is stored in the log.  Please check that for more information."
                
                        if ($null -ne $_.Exception.Response)
                        {
                            if ($_.Exception.Response.StatusCode -eq 401)
                            {
                                Write-Error "Unauthorized error returned from $url, please verify API key and try again"
                            }
                            elseif ($_.ErrorDetails.Message)
                            {                
                                Write-Error -Message "Error calling $url StatusCode: $($_.Exception.Response) $($_.ErrorDetails.Message)"
                                Write-Error $_.Exception
                            }            
                            else 
                            {
                                Write-Error $_.Exception
                            }
                        }
                        else
                        {
                            Write-Error $_.Exception
                        }
                
                        Write-Error "Stopping the deployment."
                        Exit 1
                    }    
                }
                
                function Get-ListFromOctopusApi
                {
                    param (
                        $octopusUrl,
                        $endPoint,
                        $spaceId,
                        $apiKey,
                        $propertyName
                    )
                
                    $rawItemList = Invoke-OctopusApi -octopusUrl $octopusUrl -endPoint $endPoint -spaceId $spaceId -apiKey $octopusApiKey -method "GET"
                
                    $returnList = @($rawItemList.$propertyName)
                
                    Write-Verbose "The endpoint $endPoint returned a list with $($returnList.Count) items"
                
                    return ,$returnList
                }
                
                function Get-FilteredOctopusItem
                {
                    param(
                        $itemList,
                        $itemName
                    )
                
                    if ($itemList.Count -eq 0)
                    {
                        Write-Error "Unable to find $itemName.  Exiting with an exit code of 1."
                        Exit 1
                    }  
                
                    $item = $itemList | Where-Object { $_.Name.ToLower().Trim() -eq $itemName.ToLower().Trim() }      
                
                    if ($null -eq $item)
                    {
                        Write-Error "Unable to find $itemName.  Exiting with an exit code of 1."
                        exit 1
                    }
                
                    return $item
                }
                
                function Get-OctopusItemByName
                {
                    param(
                        $itemName,
                        $itemType,
                        $endpoint,
                        $defaultValue,
                        $spaceId,
                        $octopusUrl,
                        $octopusApiKey
                    )
                
                    if ($null -ne $defaultValue)
                    {
                        return $defaultValue
                    }
                
                    if ([string]::IsNullOrWhiteSpace($itemName) -or $itemName -like "#{Octopus*")
                    {
                        Write-Verbose "The item name passed in was $itemName, returning the default value for $itemType"
                        return $defaultValue
                    }
                
                    Write-Host "Attempting to find $itemType with the name of $itemName"
                    
                    $itemList = Get-ListFromOctopusApi -octopusUrl $octopusUrl -endPoint "$($endPoint)?partialName=$([uri]::EscapeDataString($itemName))&skip=0&take=100" -spaceId $spaceId -apiKey $octopusApiKey -method "GET" -propertyName "Items"   
                    $item = Get-FilteredOctopusItem -itemList $itemList -itemName $itemName
                
                    Write-Host "Successfully found $itemName with id of $($item.Id)"
                
                    return $item
                }
                
                function Get-DeploymentTasks
                {
                    param (
                        $spaceId,
                        $project,
                        $tenant,        
                        $environmentList,
                        $octopusUrl,
                        $octopusApiKey
                    )
                
                    $taskEndPoint = "tasks?skip=0&take=100&spaces=$spaceId&includeSystem=false&project=$($project.Id)&name=Deploy&states=Success"
                
                    if ($null -ne $tenant)
                    {
                        $taskEndPoint += "&tenant=$($tenant.Id)"
                    }
                
                    $taskList = @()
                
                    foreach ($environmentId in $environmentList)
                    {
                        $octopusTaskList = Get-ListFromOctopusApi -octopusUrl $octopusUrl -endPoint "$($taskEndPoint)&environment=$environmentId" -spaceId $null -apiKey $octopusApiKey -method "GET" -propertyName "Items"
                        $taskList += $octopusTaskList
                    }
                
                    $orderedTaskList = @($taskList | Sort-Object -Property StartTime -Descending)
                    Write-Verbose "We have $($orderedTaskList.Count) number of tasks to loop through"
                
                    return $orderedTaskList
                }
                
                function Get-ProjectChannelsWithDestinationEnvironment
                {
                    param(
                        $project,
                        $environment,
                        $spaceId,
                        $octopusUrl,
                        $octopusApiKey
                    )
                
                    $channelList = Get-ListFromOctopusApi -octopusUrl $octopusUrl -endPoint "projects/$($project.Id)/channels" -spaceId $spaceId -apiKey $octopusApiKey -method "GET" -propertyName "Items"
                    $matchingChannels = @()
                
                    foreach ($channel in $channelList)
                    {
                        if ([string]::IsNullOrWhiteSpace($channel.ParentEnvironmentId) -eq $false)
                        {
                            Write-Verbose "Channel $($channel.Name) is tied to an ephemeral environment, skipping as we are looking for channels that include the target environment"
                            continue
                        }
                
                        if ($null -eq $channel.LifecycleId)
                        {
                            Write-Verbose "Channel $($channel.Name) does not have a lifecycle associated with it, using the project lifecycle"
                            $lifecyclePhases = Get-ListFromOctopusApi -octopusUrl $octopusUrl -endPoint "lifecycles/$($project.LifecycleId)/preview" -spaceId $spaceId -apiKey $octopusApiKey -method "GET" -propertyName "Phases"
                        }
                        else
                        {
                            Write-Verbose "Channel $($channel.Name) has a lifecycle associated with it, using that lifecycle"
                            $lifecyclePhases = Get-ListFromOctopusApi -octopusUrl $octopusUrl -endPoint "lifecycles/$($channel.LifecycleId)/preview" -spaceId $spaceId -apiKey $octopusApiKey -method "GET" -propertyName "Phases"
                        }
                
                        Write-Verbose "Checking if channel $($channel.Name) contains the target environment $($environment.Name)"
                        $channelContainsDestinationEnvironment = $false
                        foreach ($phase in $lifecyclePhases)
                        {
                            if ($phase.AutomaticDeploymentTargets -contains $environment.Id)
                            {
                                $channelContainsDestinationEnvironment = $true
                                break
                            }
                
                            if ($phase.OptionalDeploymentTargets -contains $environment.Id)
                            {
                                $channelContainsDestinationEnvironment = $true
                                break
                            }
                        }
                
                        if ($channelContainsDestinationEnvironment -eq $true)
                        {
                            Write-Host "Channel $($channel.Name) contains the target environment $($environment.Name)"
                            $matchingChannels += @{
                                "Channel" = $channel
                                "LifecyclePhases" = $lifecyclePhases
                            }             
                        }
                    }
                
                    if ($matchingChannels.Count -eq 0)
                    {
                        Write-Error "Unable to find any channels for project $($dependency.ProjectName) that can deploy to environment $($environment.Name).  Exiting with an exit code of 1."
                        exit 1
                    }
                
                    return $matchingChannels
                }
                
                function Get-SourceEnvironmentsFromPhase
                {
                    param(
                        $matchingChannels,
                        $environment
                    )
                
                    $sourceEnvironments = @()    
                
                    foreach ($channelInfo in $matchingChannels)
                    {
                        $lifecyclePhases = $channelInfo.LifecyclePhases
                        $lifecyclePhaseIndex = -1
                
                        for ($i = 0; $i -lt $lifecyclePhases.Count; $i++)
                        {
                            $phase = $lifecyclePhases[$i]
                            if ($phase.AutomaticDeploymentTargets -contains $environment.Id -or $phase.OptionalDeploymentTargets -contains $environment.Id)
                            {
                                $lifecyclePhaseIndex = $i
                                break
                            }
                        }
                
                        for ($i = $lifecyclePhaseIndex - 1; $i -ge 0; $i--)
                        {
                            $previousLifecyclePhase = $lifecyclePhases[$lifecyclePhaseIndex - 1]      
                            foreach ($environmentId in $previousLifecyclePhase.AutomaticDeploymentTargets)
                            {
                                if ($sourceEnvironments -notcontains $environmentId)
                                {
                                    Write-Verbose "Adding $environmentId to the source environments because it is a previous environment in $($channelInfo.Channel.Name)"
                                    $sourceEnvironments += $environmentId
                                }
                            }
                
                            foreach ($environmentId in $previousLifecyclePhase.OptionalDeploymentTargets)
                            {
                                if ($sourceEnvironments -notcontains $environmentId)
                                {
                                    Write-Verbose "Adding $environmentId to the source environments because it is a previous environment in $($channelInfo.Channel.Name)"
                                    $sourceEnvironments += $environmentId
                                }
                            }
                
                            if ($previousLifecyclePhase.IsOptionalPhase -eq $false)
                            {
                                Write-Verbose "The phase $($previousLifecyclePhase.Name) is required, stopping the search for previous phases."
                                break
                            }
                        }       
                    }  
                
                    return ,$sourceEnvironments
                }
                
                
                function Get-MatchingDeployedVersion
                {
                    param(
                        $deploymentTasks,
                        $dependency,        
                        $space,
                        $octopusUrl,
                        $octopusApiKey
                    )    
                    
                    foreach ($task in $deploymentTasks)
                    {
                        $deploymentInformation = Invoke-OctopusApi -octopusUrl $parameterOctopusInstance -endPoint "deployments/$($task.Arguments.DeploymentId)" -spaceId $space.Id -apiKey $parameterOctopusAPIKey -method "GET"
                        $releaseInformation = Invoke-OctopusApi -octopusUrl $parameterOctopusInstance -endPoint "releases/$($deploymentInformation.ReleaseId)" -spaceId $space.Id -apiKey $parameterOctopusAPIKey -method "GET"
                
                        if (Test-VersionMatchesPattern -versionToCheck $releaseInformation.Version -versionPatternToCheckAgainst $dependency.versionPattern)
                        {
                            Write-Host "Found a deployment of $($dependency.ProjectName) with version $($releaseInformation.Version) which satisfies the minimum version requirement of $($dependency.versionPattern)"
                            return $releaseInformation.Version
                            break
                        }
                    }
                
                    return $null
                }
                
                function Test-VersionMatchesPattern
                {
                    param(
                        $versionToCheck,
                        $versionPatternToCheckAgainst
                    )
                
                    $localVersionToCheck = Remove-PreReleaseTag -version $versionToCheck    
                    $localVersion = Convert-Version $localVersionToCheck
                
                    $localPatternToCheckAgainst = Remove-PreReleaseTag -version $versionPatternToCheckAgainst            
                
                    # Major wildcard - similar to ^ (e.g. 2.x)
                    if ($localPatternToCheckAgainst -match '^(\d+)\.x$') {        
                        $doesMatch = ($localVersion[0] -eq [int]$matches[1])
                
                        Write-MatchMessage -doesMatch $doesMatch -version $localVersionToCheck -pattern $versionPatternToCheckAgainst
                
                        return $doesMatch
                    }
                
                    # Exact version
                    if ($localPatternToCheckAgainst -match '^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$') {
                        $p = Convert-Version $localPatternToCheckAgainst
                        $doesMatch = ((Compare-Version $localVersion $p) -eq 0)
                
                        Write-MatchMessage -doesMatch $doesMatch -version $localVersionToCheck -pattern $versionPatternToCheckAgainst
                
                        return $doesMatch                 
                    }
                
                    # Greater than any version specified (e.g. >1.2.3 or >1.2.3.4)
                    if ($localPatternToCheckAgainst -match '>(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$') {
                        $p = Convert-Version ($localPatternToCheckAgainst.Substring(1))
                        $doesMatch = ((Compare-Version $localVersion $p) -ge 0)
                
                        Write-MatchMessage -doesMatch $doesMatch -version $localVersionToCheck -pattern $versionPatternToCheckAgainst
                
                        return $doesMatch                 
                    }
                
                    # Caret range - major version is locked (e.g. ^1.2.3 or ^1.2.3.4)
                    if ($localPatternToCheckAgainst -match '^\^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$') {
                        $p = Convert-Version ($localPatternToCheckAgainst.Substring(1))
                        $doesMatch = ($localVersion[0] -eq $p[0] -and ((Compare-Version $localVersion $p) -ge 0))
                
                        Write-MatchMessage -doesMatch $doesMatch -version $localVersionToCheck -pattern $versionPatternToCheckAgainst
                
                        return $doesMatch
                    }
                
                    # Tilde range - major and minor versions are locked (e.g. ~1.2.3 or ~1.2.3.4)
                    if ($localPatternToCheckAgainst -match '^~(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$') {
                        $p = Convert-Version ($localPatternToCheckAgainst.Substring(1))
                        $doesMatch = ($localVersion[0] -eq $p[0] -and $localVersion[1] -eq $p[1] -and (Compare-Version $localVersion $p) -ge 0)
                
                        Write-MatchMessage -doesMatch $doesMatch -version $localVersionToCheck -pattern $versionPatternToCheckAgainst
                
                        return $doesMatch
                    }
                
                    Write-Host "The version pattern $versionPatternToCheckAgainst is not recognized, unable to compare versions."
                    return $false
                }
                
                function Test-VersionIsNewer{
                    param(
                        $targetEnvironmentVersion,
                        $sourceEnvironmentVersion
                    )
                
                    if ($null -eq $sourceEnvironmentVersion)
                    {
                        Write-Host "The source environment does not have a version matching the pattern deployed, therefore it cannot be newer than the target environment."
                        return $false
                    }
                
                    if ($null -eq $targetEnvironmentVersion -and $null -ne $sourceEnvironmentVersion)
                    {
                        Write-Host "The target environment does not have does not have a version matching the pattern deployed while the source environment does.  Therefore the source environment version $sourceEnvironmentVersion is considered newer."
                        return $true
                    }    
                
                    $localTargetEnvVersionToCheck = Remove-PreReleaseTag -version $targetEnvironmentVersion    
                    $localTargetEnvVersion = Convert-Version $localTargetEnvVersionToCheck
                
                    $localSourceEnvVersionToCheck = Remove-PreReleaseTag -version $sourceEnvironmentVersion    
                    $localSourceEnvVersion = Convert-Version $localSourceEnvVersionToCheck
                
                    $isNewer = (Compare-Version $localSourceEnvVersion $localTargetEnvVersion) -gt 0
                
                    if ($isNewer)
                    {
                        Write-Host "The source environment version $sourceEnvironmentVersion is newer than the target environment version $targetEnvironmentVersion"
                    }
                    else
                    {
                        Write-Host "The source environment version $sourceEnvironmentVersion is NOT newer than the target environment version $targetEnvironmentVersion"
                    }
                
                    return $isNewer
                }
                
                function Convert-Version 
                {
                    param ($v)
                
                    if ($v -notmatch '^(\d+)\.(\d+)\.(\d+)(?:\.(\d+))?$') {
                        throw "Invalid version format: $v"
                    }
                
                    return @(
                        [int]$matches[1],
                        [int]$matches[2],
                        [int]$matches[3],
                        [int]($matches[4] ?? 0)
                    )
                }
                
                function Compare-Version {
                    param ($a, $b)
                
                    for ($i = 0; $i -lt 4; $i++) {
                        if ($a[$i] -gt $b[$i]) { return 1 }
                        if ($a[$i] -lt $b[$i]) { return -1 }
                    }
                
                    return 0
                }
                
                function Write-MatchMessage {
                    param(
                        $doesMatch,
                        $version,
                        $pattern
                    )
                
                    if ($doesMatch)
                    {
                        Write-Host "The version $version satisfies the pattern $pattern"
                    }
                    else
                    {
                        Write-Host "The version $version does not satisfy the pattern $pattern"
                    }
                }
                
                function Remove-PreReleaseTag
                {
                    param(
                        $version
                    )
                
                    $localVersionToCheck = $version
                    if ($localVersionToCheck -like "*-*")
                    {
                        Write-Verbose "Version $version contains a pre-release tag ($($localVersionToCheck.Substring($localVersionToCheck.IndexOf("-")))), removing that for comparison purposes"
                        $localVersionToCheck = $localVersionToCheck.SubString(0, $localVersionToCheck.IndexOf("-"))
                    }
                
                    if ($localVersionToCheck -like "*+*")
                    {
                        Write-Verbose "Version $version contains a pre-release tag ($($localVersionToCheck.Substring($localVersionToCheck.IndexOf("+")))), removing that for comparison purposes"
                        $localVersionToCheck = $localVersionToCheck.SubString(0, $localVersionToCheck.IndexOf("+"))
                    }
                
                    return $localVersionToCheck
                }
                
                function Get-VersionCompareResult {
                    param(
                        $deployedVersion,
                        $sourceVersionToDeploy,
                        $dependency,
                        $environment,
                        $dependencyAction,
                        $approvalRequested
                    )
                
                    $deploymentIsNeeded = $false
                    $failDeployment = $false
                    $approvalRequired = $false
                    $reason = $null
                
                    if ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy)
                    {
                        $versionComparison = Test-VersionIsNewer -targetEnvironmentVersion $deployedVersion -sourceEnvironmentVersion $sourceVersionToDeploy
                    }
                    else
                    {
                        $versionComparison = $false
                    }
                
                    if ($null -eq $deployedVersion -and $null -eq $sourceVersionToDeploy -and $deployedVersion -eq "Stop")
                    {
                        $failDeployment = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern), and there is no version matching $($dependency.versionPattern) in previous environments to deploy.  The action is Stop, so failing the deployment."        
                    }
                    elseif ($null -eq $deployedVersion -and $null -eq $sourceVersionToDeploy -and $deployedVersion -like "Deploy*")
                    {
                        $failDeployment = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern), and there is no version matching $($dependency.versionPattern) in previous environments to deploy.  The action is to deploy a newer version, but there is no version to deploy, so failing the deployment."        
                    }
                    elseif ($null -eq $deployedVersion -and $null -eq $sourceVersionToDeploy -and $deployedVersion -eq "Continue" -and $approvalRequested -eq "Yes")
                    {
                        $approvalRequired = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern), and there is no version matching $($dependency.versionPattern) in previous environments to deploy.  The action is Continue and a Approval is required to continue deployment."
                    }
                    elseif ($null -eq $deployedVersion -and $null -eq $sourceVersionToDeploy -and $deployedVersion -eq "Continue" -and $approvalRequested -eq "No")
                    {        
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern), and there is no version matching $($dependency.versionPattern) in previous environments to deploy.  The action is Continue but NO Approval is required to continue deployment."
                    }
                    elseif ($null -eq $deployedVersion -and $null -ne $sourceVersionToDeploy -and $deployedVersion -eq "Stop")
                    {
                        $failDeployment = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern). It needs to deploy $($sourceVersionToDeploy), but the action is Stop, so failing the deployment."
                    }
                    elseif ($null -eq $deployedVersion -and $null -ne $sourceVersionToDeploy -and $deployedVersion -eq "Continue" -and $approvalRequested -eq "Yes")
                    {
                        $approvalRequired = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern). It needs to deploy $($sourceVersionToDeploy), but the action is Continue and Approval is required to continue deployment without deploying dependencies."
                    }
                    elseif ($null -eq $deployedVersion -and $null -ne $sourceVersionToDeploy -and $deployedVersion -eq "Continue" -and $approvalRequested -eq "No")
                    {                
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern). It needs to deploy $($sourceVersionToDeploy), but the action is Continue but NO Approval is required to continue deployment without deploying dependencies."
                    }
                    elseif ($null -eq $deployedVersion -and $null -ne $sourceVersionToDeploy -and $deployedVersion -like "Deploy*" -and $approvalRequested -eq "Yes")
                    {
                        $approvalRequired = $true
                        $deploymentIsNeeded = $true
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern). We will deploy $($sourceVersionToDeploy), but Approval is required to continue deployment."
                    }
                    elseif ($null -eq $deployedVersion -and $null -ne $sourceVersionToDeploy -and $deployedVersion -like "Deploy*" -and $approvalRequested -eq "No")
                    {     
                        $deploymentIsNeeded = $true           
                        $reason = "$($dependency.ProjectName) does not have a version in $($environment.Name) that matches $($dependency.versionPattern). We will deploy $($sourceVersionToDeploy), and NO Approval is required to continue deployment."
                    }
                    elseif ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy -and $versionComparison -eq $false)
                    {        
                        $reason = "$($dependency.ProjectName) has version $($sourceVersionToDeploy) which matches $($dependency.versionPattern) in a previous environment, but it is NOT newer than $($deployedVersion) in $($environment.Name).  No deployment needed for $($dependency.ProjectName)."        
                    }
                    elseif ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy -and $versionComparison -eq $true -and ($dependencyAction -eq "Stop" -or $dependencyAction -eq "Continue"))
                    {        
                        $reason = "$($dependency.ProjectName) has version $($sourceVersionToDeploy) which matches $($dependency.versionPattern) in a previous environment that is newer than $($deployedVersion) in $($environment.Name).  The requirements are met and no deployment was requested, so no deployment will be performed on $($dependency.ProjectName)."        
                    }    
                    elseif ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy -and $versionComparison -eq $true -and $dependencyAction -eq "DeployNoMatchingInTarget")
                    {        
                        $reason = "$($dependency.ProjectName) has version $($sourceVersionToDeploy) which matches $($dependency.versionPattern) in a previous environment that is newer than $($deployedVersion) in $($environment.Name).  The action is to only deploy when there is nothing matching in $($environment.Name), so no deployment will be performed on any dependencies."        
                    }
                    elseif ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy -and $versionComparison -eq $true -and $dependencyAction -eq "DeployNewerMatching" -and $approvalRequested -eq "Yes")
                    {        
                        $approvalRequired = $true
                        $deploymentIsNeeded = $true
                        $reason = "$($dependency.ProjectName) has version $($sourceVersionToDeploy) which matches $($dependency.versionPattern) in a previous environment that is newer than $($deployedVersion) in $($environment.Name).  The dependency action is set to Deploy Newer Matching, so $($sourceVersionToDeploy) will be deployed, but Approval is required to continue deployment."
                    }    
                    elseif ($null -ne $deployedVersion -and $null -ne $sourceVersionToDeploy -and $versionComparison -eq $true -and $dependencyAction -eq "DeployNewerMatching" -and $approvalRequested -eq "No")
                    {                
                        $deploymentIsNeeded = $true
                        $reason = "$($dependency.ProjectName) has version $($sourceVersionToDeploy) which matches $($dependency.versionPattern) in a previous environment that is newer than $($deployedVersion) in $($environment.Name).  The dependency action is set to Deploy Newer Matching and approval is not requested, so $($sourceVersionToDeploy) will be deployed without approval."
                    }  
                    else
                    {
                        Write-Error "Unhandled version comparison case for dependency $($dependency.ProjectName).  Exiting with an exit code of 1."
                        exit 1
                    }   
                
                    return @{
                        "DeploymentIsNeeded" = $deploymentIsNeeded
                        "FailDeployment" = $failDeployment
                        "ApprovalRequired" = $approvalRequired
                        "Reason" = $reason
                    }
                }
                
                $dependencyList = ConvertFrom-Json $parameterDependencies
                
                $defaultSpace = Get-OctopusItemByName -itemName $spaceName -itemType "Space" -endpoint "spaces" -defaultValue $null -spaceId $null -defaultUrl $defaultUrl -octopusApiKey $octopusApiKey
                $defaultEnvironment = Get-OctopusItemByName -itemName $parameterTargetEnvironmentName -itemType "Environment" -endpoint "environments" -defaultValue $null -spaceId $defaultSpace.Id -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                $defaultTenant = Get-OctopusItemByName -itemName $parameterTenantName -itemType "Tenant" -endpoint "tenants" -defaultValue $null -spaceId $defaultSpace.Id -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                
                $dependencyResultList = @()
                $approvalMessageList = @()
                $requiredDeployment = $false
                $failEntireDeployment = $false
                $requireManualIntervention = $false
                foreach ($dependency in $dependencyList)
                {
                    $space = Get-OctopusItemByName -itemName $dependency.SpaceName -itemType "Space" -endpoint "spaces" -defaultValue $defaultSpace -spaceId $null -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $environment = Get-OctopusItemByName -itemName $dependency.SpaceName -itemType "Environment" -endpoint "environments" -defaultValue $defaultEnvironment -spaceId $null -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $project = Get-OctopusItemByName -itemName $dependency.ProjectName -itemType "Project" -endpoint "projects" -defaultValue $null -spaceId $space.Id -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $tenant = Get-OctopusItemByName -itemName $dependency.TenantName -itemType "Tenant" -endpoint "tenants" -defaultValue $defaultTenant -spaceId $space.Id -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                
                    $deploymentTasks = Get-DeploymentTasks -spaceId $space.Id -project $project -tenant $tenant -environmentList @($environment.Id) -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $deployedVersion = Get-MatchingDeployedVersion -dependency $dependency -deploymentTasks $deploymentTasks -space $space -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey  
                    
                    $matchingChannels = Get-ProjectChannelsWithDestinationEnvironment -project $project -environment $environment -spaceId $space.Id -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $sourceEnvironments = Get-SourceEnvironmentsFromPhase -matchingChannels $matchingChannels -environment $environment
                    $sourceDeploymentTasks = Get-DeploymentTasks -spaceId $space.Id -project $project -tenant $tenant -environmentList $sourceEnvironments -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                    $sourceVersionToDeploy = Get-MatchingDeployedVersion -dependency $dependency -deploymentTasks $sourceDeploymentTasks -space $space -octopusUrl $parameterOctopusInstance -octopusApiKey $parameterOctopusAPIKey
                
                    $dependencyCompareResult = Get-VersionCompareResult -deployedVersion $deployedVersion -sourceVersionToDeploy $sourceVersionToDeploy -dependency $dependency -environment $environment -dependencyAction $parameterOlderDependencyAction -approvalRequested $parameterApprovalRequested
                
                    Write-Highlight "$($dependencyCompareResult.Reason)"
                    
                    if ($dependencyCompareResult.DeploymentIsNeeded -eq $true)
                    {
                        $requiredDeployment = $true
                    }
                
                    if ($dependencyCompareResult.FailDeployment -eq $true)
                    {
                        $failEntireDeployment = $true
                    }
                
                    if ($dependencyCompareResult.ApprovalRequired -eq $true)
                    {
                        $requireManualIntervention = $true
                        $approvalMessageList += $dependencyCompareResult.Reason
                    }
                
                    if ($null -eq $sourceVersionToDeploy)
                    {
                        $sourceVersionToDeploy = "N/A"
                    }
                
                    $dependencyResult = @{
                        "ProjectName" = $dependency.ProjectName
                        "ProjectId" = $project.Id        
                        "SpaceName" = $space.Name
                        "SpaceId" = $space.Id
                        "versionPattern" = $dependency.VersionPattern
                        "DeployedVersion" = $deployedVersion
                        "DeployGroup" = $dependency.DeployGroup                
                        "VersionToDeploy" = $sourceVersionToDeploy
                    }
                
                    if ($null -ne $tenant)
                    {
                        $dependencyResult["TenantId"] = $tenant.Id
                        $dependencyResult["TenantName"] = $tenant.Name
                    }
                
                    $dependencyResultList += $dependencyResult
                }
                
                if ($failEntireDeployment -eq $true)
                {
                    Write-Highlight "One or more dependencies failed to meet the version requirements and the action is to Stop, failing the deployment."
                    exit 1
                }
                elseif ($requiredDeployment -eq $false -and $requireManualIntervention -eq $false)
                {
                    Write-Highlight "All dependencies satisfy the version requirements and no deployments were requested, you are clear to deploy the main project."
                    exit 0
                }
                elseif ($requiredDeployment -eq $true -and $requireManualIntervention -eq $false)
                {
                    Write-Highlight "At least one deployment will be performed to satisfy the dependencies but NO manual intervention is required."
                }
                elseif ($requiredDeployment -eq $true -and $requireManualIntervention -eq $true)
                {
                    Write-Highlight "At least one deployment will be performed to satisfy the dependencies but will pause for a manual intervention."
                }
                
                $approvalResult = $approvalMessageList -join "`n"
                Write-Host "Adding ApprovalMessages with the value $approvalResult as an output variable"
                Set-OctopusVariable -name "ApprovalMessages" -value $approvalResult
                Write-Host "Access it from future steps using: #{Octopus.ProcessTemplate.Action[$stepName].Output.ApprovalMessages}"
                
                $dependencyResultAsString = ConvertTo-Json $dependencyResult
                Write-Host "Adding DependencyResult with the value $dependencyResultAsString as an output variable"
                Set-OctopusVariable -name "DependencyResult" -value $dependencyResultAsString
                Write-Host "Access it from future steps using: #{Octopus.ProcessTemplate.Action[$stepName].Output.DependencyResult}"
                
                Write-Host "Adding ApprovalRequired with the value $requireManualIntervention as an output variable"
                Set-OctopusVariable -name "ApprovalRequired" -value $requireManualIntervention
                Write-Host "Access it from future steps using: #{Octopus.ProcessTemplate.Action[$stepName].Output.ApprovalRequired}"
                
                Write-Host "Adding DeployDependencies with the value $requiredDeployment as an output variable"
                Set-OctopusVariable -name "DeployDependencies" -value $requiredDeployment
                Write-Host "Access it from future steps using: #{Octopus.ProcessTemplate.Action[$stepName].Output.DeployDependencies}"
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
            OctopusUseBundledTooling = "False"
        }
        worker_pool_variable = "#{Template.Worker.Pool}"
    }
}

step "approve-dependency-result" {
    condition = "Variable"
    name = "Approve Dependency Result"
    properties = {
        Octopus.Step.ConditionVariableExpression = "#{unless Octopus.Deployment.Error}#{Octopus.ProcessTemplate.Action[Check Dependencies].Output.ApprovalRequired}#{/unless}"
    }

    action {
        action_type = "Octopus.Manual"
        properties = {
            Octopus.Action.Manual.BlockConcurrentDeployments = "True"
            Octopus.Action.Manual.Instructions = <<-EOT
                One or more dependencies are out of date in #{Template.Environment.Name}.  The action is currently set to #{Template.Dependency.Action}
                
                Please approve the following before deploying:
                
                #{Octopus.ProcessTemplate.Action[Check Dependencies].Output.ApprovalMessages}
                
                EOT
            Octopus.Action.Manual.ResponsibleTeamIds = "#{Template.Approval.Teams}"
        }
    }
}